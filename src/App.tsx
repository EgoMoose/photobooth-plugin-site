import React, { useState, useCallback, useMemo, useRef } from 'react';
import { UploadCloud, CheckCircle, XCircle, FileText, Code, FileArchive } from 'lucide-react';
import { useDropzone } from 'react-dropzone';
import JSZip from 'jszip';

// --- Type Definitions ---

interface Metadata {
  [key: string]: string | number
};

interface GLTFPng {
  name: string;
  uri: string;
}

interface IProcessData {
  pngs: GLTFPng[];
  metadata: Metadata;
}

interface IGLTFProcessResult {
  isValid: boolean;
  message: string;
  data: IProcessData | null;
}

// --- Utility Functions ---

const sanitizeFilename = (filename: string) => {
  let sanitized = filename.replace(/[/?%*:|"<>\x00-\x1F]/g, '_');
  // Replace spaces with hyphens (optional, but often recommended)
  sanitized = sanitized.replace(/\s/g, '-');
  // Remove leading/trailing dots or hyphens that could be problematic
  sanitized = sanitized.replace(/^[.-]+|[.-]+$/g, '');
  // Ensure no multiple consecutive underscores or hyphens
  sanitized = sanitized.replace(/[_]{2,}/g, '_');
  sanitized = sanitized.replace(/[-]{2,}/g, '-');
  return sanitized;
}

const processGLTF = (data: string): IGLTFProcessResult => {
  try {
    if (typeof data === 'string') {
      // For GLTF (JSON)
      const json = JSON.parse(data);

      if (!json.asset || !json.asset.version) {
        throw new Error("JSON is valid, but missing required 'asset' property with a 'version'.");
      }

      if (!(json.asset.generator === "Roblox Export")) {
        throw new Error("Provided glTF was not generated by Roblox Studio.");
      }

      const imgCount: number = json.images ? json.images.length : 0;
      if (imgCount === 0) {
        throw new Error("Provided glTF has no images to extract.");
      }

      const pngs: GLTFPng[] = [];
      const used: Set<number> = new Set();

      const meshCount: number = json.meshes ? json.meshes.length : 0;
      for (let i = 0; i < meshCount; i++) {
        const materialIndex: (number | undefined) = json.meshes[i].primitives[0]?.material;
        const imageIndex: (number | undefined) = typeof (materialIndex) === 'number' ? json.materials[materialIndex]?.pbrMetallicRoughness?.baseColorTexture?.index : undefined;

        if (typeof (imageIndex) === 'number' && json.meshes[i]?.name) {
          pngs.push({
            name: sanitizeFilename(json.meshes[i].name),
            uri: json.images[imageIndex].uri,
          })

          used.add(imageIndex);
        }
      }

      for (let i = 0; i < imgCount; i++) {
        if (!used.has(i)) {
          const filename = `unknown_${crypto.randomUUID()}_${pngs.length.toString()}`;
          pngs.push({
            name: filename,
            uri: json.images[i].uri,
          })
        }
      }

      const jsonData: IProcessData = {
        pngs: pngs,
        metadata: {
          ["Images"]: pngs.length,
        }
      };

      return {
        isValid: true,
        message: `Downloading images...`,
        data: jsonData,
      };
    } else {
      throw new Error("Invalid data format for the selected mode.");
    }
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'An unknown processing error occurred.';

    return {
      isValid: false,
      message: `Processing Error: ${errorMessage}`,
      data: null,
    };
  }
};

const savePng = (png: GLTFPng) => {
  var a = document.createElement("a");
  a.href = png.uri;
  a.download = `${png.name}.png`;
  a.click();
}

const zipAndSavePngs = (zipName: string, pngs: GLTFPng[]) => {
  const zip = new JSZip();
  for (const png of pngs) {
    const b64 = png.uri.split(",")[1]
    zip.file(`${png.name}.png`, b64, { base64: true });
  }

  zip.generateAsync({ type: "blob" })
    .then(function (content) {
      var downloadLink = document.createElement("a");
      downloadLink.href = URL.createObjectURL(content);
      downloadLink.download = `${zipName}.zip`;
      document.body.appendChild(downloadLink);
      downloadLink.click();
      document.body.removeChild(downloadLink);
    })
    .catch(function (error) {
      throw new Error("Error generating zip file:", error);
    });
}

const downloadPngs = (pngs: GLTFPng[], zipName: string | null) => {
  if (zipName && pngs.length > 1) {
    zipAndSavePngs(zipName, pngs);
  } else {
    for (const png of pngs) {
      savePng(png)
    }
  }
}

// --- Components ---

const Header: React.FC = () => (
  <header className="bg-gray-900 border-b border-gray-800 p-4 fixed w-full z-10 shadow-lg">
    <div className="max-w-7xl mx-auto flex justify-between items-center">
      <div className="flex items-center space-x-6">
        <button className="flex items-center text-2xl font-bold text-indigo-400 font-mono hover:text-indigo-500 transition duration-300">
          <span className="text-gray-100">Photo</span>
          <span className="text-indigo-500">booth</span>
        </button>
      </div>

      <a
        href="https://devforum.roblox.com/t/3401720"
        target="_blank"
        rel="noopener noreferrer"
        className="px-4 py-2 bg-indigo-600 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-700 transition duration-300 flex items-center space-x-2"
      >
        <span>Get Plugin</span>
      </a>
    </div>
  </header>
);

const GLTFProcessor: React.FC = () => {
  const fileInputRef = useRef<HTMLInputElement>(null);
  const [inputText, setInputText] = useState<string>('');
  const [fileInput, setFileInput] = useState<File | null>(null);
  const [processingResult, setProcessingResult] = useState<IGLTFProcessResult | null>(null);
  const [isLoading, setIsLoading] = useState<boolean>(false);
  const [mode, setMode] = useState<'upload' | 'paste'>('upload'); // 'upload' or 'paste'
  const [alphaBleedingEnabled, _setAlphaBleedingEnabled] = useState<boolean>(false); // State for alpha bleeding
  const [fileZippingEnabled, setFileZippingEnabled] = useState<boolean>(true);

  const handleProcess = useCallback((): (() => (void)) => {
    setIsLoading(true);
    setProcessingResult(null);

    // Simulate API delay
    const timeoutId = setTimeout(() => {
      let result: IGLTFProcessResult | null = null;

      if (mode === 'paste' && inputText) {
        result = processGLTF(inputText);
      } else {
        result = { isValid: false, message: "Please provide file data or paste JSON.", data: null };
      }

      // Append the alpha bleeding status to the result data for demonstration
      if (result && result.data) {
        //result.data.metadata['Alpha Bleed'] = alphaBleedingEnabled ? 'true' : 'false';
        downloadPngs(result.data.pngs, fileZippingEnabled ? "gltf_images" : null);
      }

      setProcessingResult(result);
      setIsLoading(false);
    }, 500); // Small delay for realism

    // Clear timeout on unmount or re-run
    return () => clearTimeout(timeoutId);
  }, [mode, fileInput, inputText, alphaBleedingEnabled, fileZippingEnabled]);

  const { getRootProps, getInputProps, open } = useDropzone({
    noClick: true, // Important: Prevents opening file dialog on dropzone click
    accept: {
      'model/gltf+json': ['.gltf'],
    },
    onDrop: acceptedFiles => {
      const file = acceptedFiles[0];
      if (!file) return;

      setFileInput(file);
      setInputText(''); // Clear text input mode if file is selected
      setProcessingResult(null); // Clear previous result

      const reader = new FileReader();
      reader.onloadstart = () => setIsLoading(true);
      reader.onload = (e: ProgressEvent<FileReader>) => {
        let data: string | ArrayBuffer | null = e.target?.result ?? null;
        let result: IGLTFProcessResult;

        if (data) {
          // Actual file data parsing is complex, we just check headers and run the mock process
          if (typeof data === 'string') {
            result = processGLTF(data);
          } else {
            result = { isValid: false, message: "Unsupported file reader result type.", data: null };
          }
        } else {
          result = { isValid: false, message: "File data could not be read.", data: null };
        }

        // Append the alpha bleeding status to the result data for demonstration
        if (result && result.data) {
          //result.data.metadata['Alpha Bleed'] = alphaBleedingEnabled ? 'true' : 'false';
          downloadPngs(result.data.pngs, fileZippingEnabled ? "gltf_images" : null);
        }

        setProcessingResult(result);
        setIsLoading(false);
        if (fileInputRef.current) {
          fileInputRef.current.value = ''
        }
      };
      reader.onerror = () => {
        setProcessingResult({ isValid: false, message: "Error reading file.", data: null });
        setIsLoading(false);
        if (fileInputRef.current) {
          fileInputRef.current.value = ''
        }
      };

      reader.readAsText(file);
    },
  });

  const handleModeToggle = (newMode: 'upload' | 'paste'): void => {
    setMode(newMode);
    setFileInput(null);
    setInputText('');
    setProcessingResult(null);
  }

  const resultIcon = useMemo(() => {
    if (!processingResult) return null;
    const commonClasses = "w-8 h-8 mr-3";
    if (processingResult.isValid) {
      return <CheckCircle className={`${commonClasses} text-green-400`} />;
    }
    return <XCircle className={`${commonClasses} text-red-400`} />;
  }, [processingResult]);

  return (
    <section className="py-20 bg-gray-900 border-t border-gray-800 min-h-screen pt-16">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <h2 className="text-4xl font-bold text-center text-white mb-4">
          <span className="text-indigo-400">GLTF</span> To Png
        </h2>
        <p className="text-xl text-center text-gray-500 mb-12">
          Convert glTF files generated from Photobooth images into pngs.
        </p>

        <div className="bg-gray-800 p-8 rounded-xl shadow-2xl max-w-4xl mx-auto border border-gray-700">
          {/* Mode Tabs */}
          <div className="flex border-b border-gray-700 mb-6">
            <button
              onClick={() => handleModeToggle('upload')}
              className={`py-3 px-6 font-semibold rounded-t-lg transition duration-300 ${mode === 'upload' ? 'bg-indigo-600 text-white' : 'text-gray-400 hover:bg-gray-700'
                }`}
            >
              <UploadCloud className="inline w-5 h-5 mr-2" /> Upload File (.gltf)
            </button>
            <button
              onClick={() => handleModeToggle('paste')}
              className={`py-3 px-6 font-semibold rounded-t-lg transition duration-300 ${mode === 'paste' ? 'bg-indigo-600 text-white' : 'text-gray-400 hover:bg-gray-700'
                }`}
            >
              <FileText className="inline w-5 h-5 mr-2" /> Paste JSON (.gltf)
            </button>
          </div>

          {/* Alpha Bleeding Toggle (Relocated) */}
          {/* <div className="flex items-center space-x-3 mb-6 p-3 bg-gray-700 rounded-lg">
            <Image className="w-5 h-5 text-indigo-400" />
            <label htmlFor="alpha-bleeding" className="text-gray-300 font-medium cursor-pointer flex items-center">
              Alpha Bleed
            </label>

            <button
              id="alpha-bleeding"
              onClick={() => setAlphaBleedingEnabled(prev => !prev)}
              className={`relative ml-auto inline-flex flex-shrink-0 h-6 w-11 border-2 border-transparent rounded-full cursor-pointer transition-colors ease-in-out duration-200 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-700 ${alphaBleedingEnabled ? 'bg-green-600' : 'bg-gray-600'}`}
              aria-pressed={alphaBleedingEnabled}
            >
              <span className="sr-only">Toggle alpha bleeding</span>
              <span
                aria-hidden="true"
                className={`pointer-events-none inline-block h-5 w-5 rounded-full bg-white shadow transform ring-0 transition ease-in-out duration-200 ${alphaBleedingEnabled ? 'translate-x-5' : 'translate-x-0'}`}
              ></span>
            </button>
          </div> */}

          {<div className="flex items-center space-x-3 mb-6 p-3 bg-gray-700 rounded-lg">
            <FileArchive className="w-5 h-5 text-indigo-400" />
            <label htmlFor="file-zipping" className="text-gray-300 font-medium cursor-pointer flex items-center">
              Zip Files
            </label>

            <button
              id="file-zipping"
              onClick={() => setFileZippingEnabled(prev => !prev)}
              className={`relative ml-auto inline-flex flex-shrink-0 h-6 w-11 border-2 border-transparent rounded-full cursor-pointer transition-colors ease-in-out duration-200 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-700 ${fileZippingEnabled ? 'bg-green-600' : 'bg-gray-600'}`}
              aria-pressed={fileZippingEnabled}
            >
              <span className="sr-only">Toggle file zipping</span>
              <span
                aria-hidden="true"
                className={`pointer-events-none inline-block h-5 w-5 rounded-full bg-white shadow transform ring-0 transition ease-in-out duration-200 ${fileZippingEnabled ? 'translate-x-5' : 'translate-x-0'}`}
              ></span>
            </button>
          </div>}


          {/* Input Area */}
          {mode === 'upload' ? (
            <div className="flex flex-col items-center justify-center p-10 border-4 border-dashed border-indigo-700 rounded-lg bg-gray-700/50" {...getRootProps()}>
              <UploadCloud className="w-12 h-12 text-indigo-400 mb-3" />
              <p className="text-white text-lg font-semibold mb-2">Drag & Drop or Click to Upload</p>
              <p className="text-gray-400 text-sm mb-4">Select file to convert to pngs.</p>
              <button
                onClick={open}
                className="w-full md:w-auto px-6 py-3 bg-indigo-600 text-white font-semibold rounded-full shadow-md hover:bg-indigo-700 transition duration-300 transform hover:scale-[1.02]"
              >
                Choose File
              </button>
              <input
                type="file"
                accept=".gltf"
                className="hidden"
                ref={fileInputRef}
                {...getInputProps()}
              />
            </div>
          ) : (
            <div className="flex flex-col">
              <textarea
                value={inputText}
                onChange={(e: React.ChangeEvent<HTMLTextAreaElement>) => setInputText(e.target.value)}
                rows={10}
                placeholder="Paste your glTF JSON content here..."
                className="w-full p-4 bg-gray-700 text-gray-100 border border-gray-600 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 font-mono text-sm resize-none"
              ></textarea>
              <button
                onClick={handleProcess}
                disabled={!inputText || isLoading}
                className={`mt-4 py-3 px-6 rounded-lg text-white font-bold transition duration-300 ${!inputText || isLoading
                  ? 'bg-gray-600 cursor-not-allowed'
                  : 'bg-indigo-600 hover:bg-indigo-700 transform hover:scale-[1.01]'
                  }`}
              >
                {isLoading ? 'Processing...' : 'Process glTF JSON'}
              </button>
            </div>
          )}


          {/* Result Area */}
          {processingResult && (
            <div className={`mt-8 p-6 rounded-lg ${processingResult.isValid ? 'bg-green-900/40 border border-green-700' : 'bg-red-900/40 border border-red-700'
              }`}>
              <div className="flex items-center mb-4">
                {resultIcon}
                <h3 className="2xl font-bold text-white">
                  {processingResult.isValid ? 'Success' : 'Failed'}
                </h3>
              </div>
              <p className={`mb-4 ${processingResult.isValid ? 'text-green-300' : 'text-red-300'}`}>
                {processingResult.message}
              </p>

              {processingResult.data && (
                <div className="space-y-2 p-4 bg-gray-700 rounded-lg">
                  <h4 className="text-lg font-semibold text-white border-b border-gray-600 pb-2 flex items-center">
                    <Code className="w-4 h-4 mr-2" /> Extracted Metadata & Settings:
                  </h4>
                  {Object.entries(processingResult.data.metadata).map(([key, value]) => (
                    <p key={key} className="text-sm text-gray-300">
                      <span className="font-mono text-indigo-300 pr-2">{key}:</span>
                      {value}
                    </p>)
                  )}
                </div>
              )}
            </div>
          )}
        </div>
      </div>
    </section>
  );
};


// --- Main App Component ---

const App: React.FC = () => {
  return (
    <div className="min-h-screen bg-gray-950 font-sans">
      <style>{`
        /* Custom style to ensure the page content always starts below the fixed header */
        .min-h-screen-minus-header {
            min-height: calc(100vh - 64px); /* Assuming header height is around 64px (p-4 + padding/text size) */
        }
      `}</style>
      <Header />
      <main className="pt-16">
        <GLTFProcessor />
      </main>
    </div>
  );
};

export default App;